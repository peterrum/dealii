<br>

<i>
This program was contributed by Johannes Heinz, Marco Feder and Peter Munch.
Many ideas presented here are the result of common code development with
Maximilian Bergbauer, Niklas Fehn, Luca Heltai, Martin Kronbichler,
Nils Much, Judith Pauen and Magdalena Schreter-Fleischhacker.
<b> //TODO: @Peter correct people mentioned? </b>

This tutorial is loosely based on the puplication
"High-order non-conforming discontinuous Galerkin methods for the acoustic conservation equations"
by Johannes Heinz, Peter Munch and Manfred Kaltenbacher @cite heinz2023high.

Johannes Heinz was supported by the European Union’s Framework Programme for Research
and Innovation Horizon 2020 (2014-2020) under the Marie Skłodowská--Curie Grant
Agreement No. [812719].
</i>

@dealiiTutorialDOI{10.5281/zenodo.10033975,https://zenodo.org/badge/DOI/10.5281/zenodo.10033975.svg}

<h1>Introduction</h1>

This tutorial presents one way how to apply non-matching and/or Chimera methods
within matirx-free loops in deal.II.
We are following @cite heinz2023high to show that in some cases a simple point-to-point
interpolation is not sufficient. Therefore, Nitsche-type mortaring is used to suppress
artificial modes observed for the acoustic conservation equations @cite heinz2023high.

<h3>%Acoustic conservation equations</h3>

Acoustic conservation equations are used to describe linear wave propagation.
The set of equations consists of the conservation of mass and momentum
@f[
  \frac{\partial \, p}{\partial \, t} + \rho c^2 \nabla\cdot \mathbf{u} = 0,\\
  \frac{\partial \, \mathbf{u}}{\partial \, t} + \frac{1}{\rho}\nabla p = \mathbf{0}.
@f]
Here, $p$ is the acoustic pressure, $\mathbf{u}$ the acoustic particle velocity, $c$ the
speed of sound, and $\rho$ the medium density of the fluid in which waves are propagating.
Within this tutorial we are exclusively using homogenous pressure boundary conditions.
For the discretization we make use of discontinuous Galerkin (DG) methods. DG methods are
especially attractive for the acoustic conservation equations due to their low numerical
dispersion errors. More importantly for this tutorial, DG methods natively extend to non-matching
Nitsche-type methods @cite arnold2002unified. I.e., numerical fluxes are not only used on inner
element faces but also as non-matching coupling conditions.

The discretized equations read
@f[
  \int_{\Omega} q_h\frac{\partial \, p_h}{\partial \, t} +\int_{\Omega} q_h \rho c^2 \nabla\cdot\mathbf{u}_h +\int_{\partial\Omega} q_h\mathbf{n}\cdot\rho c^2(\mathbf{u}^*_h-\mathbf{u}_h)=0,\\
  \int_{\Omega} \mathbf{w}_h\cdot\frac{\partial \,\mathbf{u}_h}{\partial \, t} +\int_{\Omega} \mathbf{w}_h\cdot \frac{1}{\rho} \nabla p_h +\int_{\partial\Omega} \mathbf{w}_h \cdot\mathbf{n} \frac{1}{\rho}(p^*_h-p_h)=\mathbf{0},
@f]
where $\mathbf{w}_h$ and $q_h$ are test functions. The numerical fluxes are
defined as follows @cite hochbruck2014efficient
@f[
  p_h^*=p_h-\frac{\tau^-}{\tau^-+\tau^+}[p_h]+\frac{\tau^-\tau^+}{\tau^-+\tau^+}\jump{\mathbf{u}_h},\\
  \mathbf{u}_h^*=\mathbf{u}_h-\frac{\gamma^-}{\gamma^-+\gamma^+}[\mathbf{u}_h]+\frac{\gamma^-\gamma^+}{\gamma^-+\gamma^+}\jump{p_h},
@f]
with the penalty parameters $\tau=\frac{\rho c}{2}$ and $\gamma=\frac{1}{2\rho c}$.
$[a] = a^- - a^+ $ denotes the jump of an arbitrary quantity $a$
over element faces (face between elements $K^-$ and $K^+$) and
$\jump{a} = a^- \mathbf{n}^- + a^+ \mathbf{n}^+$.
For homogenous materials, the fluxes reduce to standard Lax--Friedrichs fluxes
($\gamma^-=\gamma^+$ and $\tau^-=\tau^+$)
@f[
  p_h^*=\average{p_h}+\tau\jump{\mathbf{u}_h},\\
  \mathbf{u}_h^*=\average{\mathbf{u}_h}+\gamma\jump{p_h}.
@f]
$\average{a}=\frac{a^- + a^+}{2}$ denots the averaging operator.

<h3>%Point-to-point interpolation</h3>

@image html step-89-p2p.svg "" width=15%

Point-to-point interpolation is a naive approach. The points in which values/gradients are
queried in the coupling terms are defined by the quadrature points on the element face of
element $K^-$. As it can be seen from the picture this approach might be subject to aliasing
in some cases. In the picture, information from element $K_1^+$ is completely neglected.

<h3>%Nitsche-type mortaring</h3>

@image html step-89-mortar.svg "" width=15%

Mortaring is the process of computing intersections and is not related to the Mortar method which
enforces the coupling via Lagrange multipliers. Obtained intersections are also referred to as
mortars. On each mortar a new integration rule is defined. The integral of the face of element
$K^-$ is computed on the intersections. This way, the numerical integration is exact as long
as a sufficient number of integration points is used.

TODO_BEGIN
<h3>%TODO: filling distributing intersected quadrature points with cgal!</h3>

<h3>%FERemoteEvaluation</h3>

FERemoteEvaluation is a wrapper class which provides a similar interface to, e.g., FEEvaluation to access values over non-matching interfaces in matrix-free loops.
A detailed description on how to setup the class and how to use it in actual code is given below on hands-on examples.
Within this tutorial we only show the usage for non-matching discretizations.
Note however that FERemoteEvaluation can also be used in other settings such as volume coupling.
Under the hood, Utilities::MPI::RemotePointEvaluation is used to query the solution or gradients in these points.
A detailled description how this is done can be found in step-87.
The main difference in the usage of FERemoteEvaluation compared to FEEvaluation is that values/gradients are cached <i>before</i> each loop and only accessed inside the loop.
I.e., the code differs as follows: First the standard code to evaluate fluxes via FEEvaluation
@code
const auto face_function =
  [&](const auto &data, auto &dst, const auto &src, const auto face_range) {

    FEFaceIntegrator phi_m(data, true);
    FEFaceIntegrator phi_p(data, false);

    for (unsigned int f = face_range.first; f < face_range.second; ++f)
    {
      phi_m.reinit(f);
      phi_p.reinit(f);

      phi_p.gather_evaluate(src, EvaluationFlags::values); //compute values on face f

      for (unsigned int q = 0; q < phi_m.n_q_points; ++q)
        phi_m.submit_value(phi_p.get_value(q), q); //access values

      phi_m.integrate_scatter(EvaluationFlags::values, dst);
     }
   };

matrix_free.template loop<VectorType, VectorType>({}, face_function, {}, dst, src);
@endcode
Second the code to evaluate fluxes over non-matching faces. Lets assume all boundary faces are somehow connected non-conformingly to be able to focus
on the relevant differences.

@code
const auto boundary_function =
  [&](const auto &data, auto &dst, const auto &src, const auto face_range) {

    FEFaceIntegrator phi_m(data, true);
    // remote_communicator is assumed to be initialized at this place
    FERemoteEvaluation<dim,Number> phi_p(remote_communicator);
    phi_p.gather_evaluate(src, EvaluationFlags::values);

    for (unsigned int f = face_range.first; f < face_range.second; ++f)
    {
      phi_m.reinit(f);
      phi_r.reinit(f);

      for (unsigned int q = 0; q < phi_m.n_q_points; ++q)
        phi_m.submit_value(phi_r.get_value(q), q); //access values

      phi_m.integrate_scatter(EvaluationFlags::values, dst);
    }
  };

matrix_free.template loop<VectorType, VectorType>({}, {}, boundary_function, dst, src);
@endcode
@c remote_communicator is of type FERemoteCommunicator and assumed to be correctly initialized in above code snippet.
FERemoteCommunicator internally manages the update of ghost values over non-matching interfaces and keeps track of the
mapping between quadrature point index and correspoding values/gradients. The update of the values/gradients happens
<i>before</i> the actual matrix-free loop.
TODO_END

<h3>Overview</h3>

In the following, point-to-point interpolation and Nitsche-type mortaring is implemented.
At first we are considering the test case of a vibrating membrane, for which the analytical
solution is known. For the point-to-point interpolation we observe instabilities which can
be resolved using Nitsche-type mortaring.
In a more realistic example we effectvely apply the implementations to a test case in which a wave
is propagating from one fluid into another fluid. I.e., the wave length is directly proportional to the
speed of sound and therefore, different element sizes are required to resolve waves up to the same
frequency in both fluids.
